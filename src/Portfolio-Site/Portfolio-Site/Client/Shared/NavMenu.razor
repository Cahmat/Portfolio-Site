@using PortfolioSite.Client.Helpers
@inject IJSRuntime JSRuntime

<div id="nav-wrapper">
    <div @ref="toggle" id="toggle-capsule">
        <div class="toggle-capsule-left"></div>
        <div class="toggle-capsule-right"></div>
        <div class="nav-toggle"
                                @ontouchstart="OnTouchStart" @ontouchstart:stopPropagation="true" @ontouchstart:preventDefault="true"
                                @ontouchend="OnTouchEnd" @ontouchend:stopPropagation="true" @ontouchend:preventDefault="true"
                                @onmousedown="OnMouseStart" @onmousedown:stopPropagation="true" @onmousedown:preventDefault="true"
                                @onmousemove="OnMouseMove" @onmousemove:stopPropagation="true" @onmousemove:preventDefault="true"
                                @onmouseup="OnMouseEnd" @onmouseup:stopPropagation="true" @onmouseup:preventDefault="true">
            <img src="/css/icons/fi-xnsuxl-three-bars-solid.svg" />
        </div>
    </div>

    <nav @ref="nav" id="primary-nav" class="primary-nav">
        <a href="home" class="nav-logo">CF</a>
        <ul>
            @NavItems
        </ul>
    </nav>
</div>

@code {
    ElementReference toggle;
    ElementReference nav;

    [Parameter]
    public RenderFragment? NavItems { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //await JSRuntime.InvokeVoidAsync("addToggleSwipeListener", toggle);
    }

    async Task OnNavDragStart(MouseEventArgs mouseEventArgs)
    {
        //await JSRuntime.StartNavDrag(toggle, mouseEventArgs.ScreenY);
    }

    async Task OnNavDrag(MouseEventArgs mouseEventArgs)
    {
        //await JSRuntime.UpdateNavDrag(toggle, mouseEventArgs.OffsetY);
    }

    async Task OnNavDragEnd(MouseEventArgs mouseEventArgs)
    {
        //await JSRuntime.EndNavDrag(toggle, mouseEventArgs.ScreenY);
    }

    public async Task ToggleNav()
    {
        await JSRuntime.ToggleClass(toggle, "active");
        await JSRuntime.ToggleClass(nav, "active");
    }

    public async Task ShowNav()
    {
        await JSRuntime.AddClass(toggle, "active");
        await JSRuntime.AddClass(nav, "active");
    }

    public async Task HideNav()
    {
        await JSRuntime.RemoveClass(toggle, "active");
        await JSRuntime.RemoveClass(nav, "active");
    }

    private bool following;
    private double? xDown, yDown;
    private int sensitivity = 10;

    private async Task OnMouseStart(MouseEventArgs args)
    {
        following = true;
        xDown = args.ClientX;
        yDown = args.ClientY;
        Console.WriteLine("MouseStart");
    }

    private async Task OnMouseMove(MouseEventArgs args)
    {
        Console.WriteLine($"MouseMove: following {following}");
        if (following)
        {
            await JSRuntime.UpdateNavDrag(toggle, args.ClientY);
        }
    }

    private async Task OnMouseEnd(MouseEventArgs args)
    {
        Console.WriteLine("MouseDownEnd");
        following = false;
        await JSRuntime.UpdateNavDrag(toggle, args.ClientY);

        if (xDown == null || yDown == null)
            return;

        var xDiff = xDown.Value - args.ClientX;
        var yDiff = yDown.Value - args.ClientY;

        if (Math.Abs(xDiff) < sensitivity && Math.Abs(yDiff) < sensitivity)
        {
            xDown = yDown = null;
            return;
        }

        if (Math.Abs(xDiff) > Math.Abs(yDiff))
        {
            if (xDiff > 0)
            {
                await InvokeAsync(() => OnSwipe(SwipeDirection.RightToLeft));
            }
            else
            {
                await InvokeAsync(() => OnSwipe(SwipeDirection.LeftToRight));
            }
        }
        else
        {
            if (yDiff > 0)
            {
                await InvokeAsync(() => OnSwipe(SwipeDirection.BottomToTop));
            }
            else
            {
                await InvokeAsync(() => OnSwipe(SwipeDirection.TopToBottom));
            }
        }
        xDown = yDown = null;
    }

    private void OnTouchStart(TouchEventArgs args)
    {
        Console.WriteLine("TouchStart");
        xDown = args.Touches[0].ClientX;
        yDown = args.Touches[0].ClientY;
    }


    private void OnTouchEnd(TouchEventArgs arg)
    {
        Console.WriteLine("TouchEnd");
        if (xDown == null || yDown == null)
            return;

        var xDiff = xDown.Value - arg.ChangedTouches[0].ClientX;
        var yDiff = yDown.Value - arg.ChangedTouches[0].ClientY;

        if (Math.Abs(xDiff) < sensitivity && Math.Abs(yDiff) < sensitivity)
        {
            xDown = yDown = null;
            return;
        }

        if (Math.Abs(xDiff) > Math.Abs(yDiff))
        {
            if (xDiff > 0)
            {
                InvokeAsync(() => OnSwipe(SwipeDirection.RightToLeft));
            }
            else
            {
                InvokeAsync(() => OnSwipe(SwipeDirection.LeftToRight));
            }
        }
        else
        {
            if (yDiff > 0)
            {
                InvokeAsync(() => OnSwipe(SwipeDirection.BottomToTop));
            }
            else
            {
                InvokeAsync(() => OnSwipe(SwipeDirection.TopToBottom));
            }
        }
        xDown = yDown = null;
    }

    private async Task OnSwipe(SwipeDirection swipeDirection)
    {
        Console.WriteLine($"Swiped: {swipeDirection.ToString()}");
        switch(swipeDirection)
        {
            case SwipeDirection.TopToBottom:
                await ShowNav();
                break;
            case SwipeDirection.BottomToTop:
                await HideNav();
                break;
        }

    }

    private enum SwipeDirection
    {
        RightToLeft,
        LeftToRight,
        BottomToTop,
        TopToBottom
    }
}
